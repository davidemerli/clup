The implementation of the CLup prototype is divided in two parts: Frontend and Backend.

\subsection{Backend Frameworks and Languages}

\subsubsection{CLup Server and API}
The framework chosen for the backend is Flask. Flask is a lightweight WSGI web application framework written in python. Flask is very good for prototyping web application and APIs because it is very easy to set up (it can be installed with a single command from the python package installer PIP) and comes with a debug mode that speeds up the debugging process.
Along with flask, some other libraries were used to build the CLup Server Api.
\begin{itemize}
    \item \textbf{SQLAlchemy} is a Object Relational Mapper library (ORM). An ORM allows to map the database entities and the relationship between them to objects and references in the application code. The ORM will translate operations on the objects to SQL queries that will be executed on the database. The ORM decouples the application from the database. In this way the application code is independent from the underlying DBMS, and the latter could be changed without modifying the application code.
    \item \textbf{Marshmallow} is a marshalling library for python, well integrated with flask. Marshalling consists in converting objects from the memory in a format ready for storage or transmission. Marshmallow makes the validation the request inputs a lot simpler so the programmer doesn't need to write a lot of error-prone boilerplate code for the input validation
    \item \textbf{Flask-RESTful} The CLupServer API uses the RESTful architectural style. Flask-RESTful simplifies the code writing of this type of APIs, providing the programmer a software interface to declare each endpoint as a class, containing the different HTTP methods accepted by the endpoints. For example, to implement an endpoint that allows to create ticket with a POST request, it is sufficient to declare a class `CreateTicket' that extends the class Resource (provided by FlaskRestful), and implement the post() method.
    \item \textbf{Flask-Jwt-Extended} is a library for handling the authentication in flask using JWT tokens. A JWT token is an encoded string generated by the server and given to the user after checking its credentials. The JWT contains the user e-mail, an expiration timestamp and an hash for checking integrity. The JWT token is generated when the user makes a login request. Every request done by the user (that requires authentication) must contain this token, then flask-jwt-extended will check the validity of the token at each request. With flask-jwt-extended, allowing the access to an API endpoint to only the authenticated user is very straightforward, it's enough to put a python annotation before the endpoint methods for which authentication is needed.
\end{itemize}
\subsubsection{Data layer}
Regarding the data model a SQL relational database was preferred with respect to a noSQL one, because the data to persist has a well defined Entity-Relation structure (i.e. Tickets, Users, Stores\ldots).

For the Data layer a postgreSQL DBMS was adopted. PostgreSQL is a production ready open-source relational SQL database. It's stable and used in a lot of commercial applications so it's a good fit for the CLup prototype.

\subsubsection{Development Tools}
Different development tools are used when writing and debugging the backend code.
\begin{itemize}
    \item \textbf{Poetry} is a tool that helps managing the dependencies of a project, setting them up in an isolated python environment. Isolating the execution environment is essential to enhance the portability and the maintainability of the software. When poetry is set up it will create automatically a virtual python environment for the project and resolve the dependencies.
    \item \textbf{Black} is an automatic python code formatter. Black formats the code according to the PEP-8 standard, enhancing the readability.
    \item \textbf{pytest} is the official python testing framework. (More about the testing on section 5)
\end{itemize}

\subsubsection{Deployment Tools}
\textbf{Docker} is an useful tool to automatically build and ship applications. A Docker application is made of different containers each one running a different application, these application can communicate using an internal network.

For this prototype, docker was employed to build and deploy the backend using a single command.
Without docker, each component (i.e. CLup Server Application, Database, Load Balancer) should have been set up manually.

\medskip

To deploy the application in production it is not recommended to use the flask development WSGI server. So the CLup Server Application container runs a \textbf{gunicorn} server.

\medskip

\textbf{Nginx} is a widely used load balancer. Due to the low usage of a prototype application, a load balancer is not strictly needed, but it is included for enhancing the stability of the gunicorn server and can be useful to have better performance when stress testing the system.

\subsection{Frontend}
\subsubsection{Flutter}

For the application frontend we decided to use the Flutter framework considering its many advantages:
\begin{itemize}
    \item Flutter allows to natively compile applications for every major platform, including Android, IOs, Web and Desktop applications. By using a single code base it is possible to deliver the same experience to every platform, and without the need to define different teams for every version.
    \item Natively compiling applications ensures good performances even if not writing native code for the specific target platforms.
    \item Flutter provides lots of predefined Widgets\footnote{Every component in a Flutter application is a Widget, and every displayed page is a Tree of Widgets, one inside the other; working with Widgets allows to only rebuild the parts of the application that need to be updated, which improves performance.} for every kind of situation. This allows for faster developement since every common behavior in a classic application is already usable out of the box
    \item There are lots of libraries (both official and third party libraries) that further populate the list of usable Widgets (i.e. libraries to draw graphs with statistics, map integration, HTTP requests, QR code scanning/generation)
    \item Flutter allows for 'Hot Reloading', which instantly rebuilds the application while debugging, and without necessarly restarting the application, speeding up the developement processruns onruns on
    \item Flutter is written with the Dart programming language, which is very flexible, has very powerful features (like Mixins and Extensions Methods, but also a very polished null safety implementation) and resembles Java in the general syntax (which is a known language to team members)
    \item Team members already had some experience with the framework
\end{itemize}

On the other hand, Flutter has some downsides:
\begin{itemize}
    \item Flutter Web is still in beta developement, so it has not been tested enough to be considered 'stable', but the developement of the framework is very active, and behind the project there is Google.
    \item Some low level features, for example the interaction with background tasks in the various operating systems running the application, are not yet supported natively (in Dart code) but may require small amounts of codes to be written in the respective native languages (i.e. Java/Kotlin for Android, Swift for IOs)
\end{itemize}

\subsubsection{External Libraries}

To speed up the developement process some external libraries were used, here are listed the most important ones:

\begin{itemize}
    \item \textbf{font\_awesome\_flutter}: Font Awesome is a font and icon toolkit that is widely used for the vaste collection of icons it provided, for almost every use case.
    \item \textbf{dio}: Dio is a powerful Http client for Dart, which supports Interceptors, Global configuration, FormData, Request Cancellation, File downloading, Timeout etc. It is very useful for making and handling requests to the CLup API.
    \item \textbf{google\_maps\_flutter}: A Flutter plugin that provides a Google Maps widget. It is an official library from the Flutter team, and (along with \textbf{google\_maps\_flutter\_web}) allows the CLup application to interact with the map, put marks where the stores are located, etc.
    \item \textbf{qr\_flutter}: QR.Flutter is a Flutter library for simple and fast QR code rendering via a Widget or custom painter. It was used to render the ticket information in a QR Code for an easy scan of the tickets.
    \item \textbf{barcode\_scan}: A flutter plugin for scanning 2D barcodes and QR codes. It is a discontinued library but was the fastest to setup and very easy to use, should be substituted with another library for the final product. Integrates with Android and IOs but not with Flutter web, so on the webapp it is only possible to scan tickets by typing the ticketID.
    \item \textbf{geolocator}: A Flutter geolocation plugin which provides easy access to platform specific location services. On the webapp (which can be used on desktop devices without GPS sensors) the location is obtainaed through an API request that geolocalizes with IP addresses.
\end{itemize}